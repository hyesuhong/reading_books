# 요약

멀티 스레드를 사용하는 동시성은 복잡해지기 쉽기 때문에 깔끔한 코드와 양립하기 어렵다. 13장에서 논할 내용은 아래와 같다.
1. 멀티 스레드를 돌리는 이유
2. 멀티 스레드의 어려움
3. 대처 방법과 깨끗한 코드를 작성하는 방법
4. 테스트 방법과 문제점

## 동시성이 필요한 이유
### 동시성이란
`무엇` 과 `언제` 의 결합을 분리하는 전략

### 동시성을 선택하는 이유
- 애플리케이션 구조와 효율의 향상을 기대할 수 있음
- 응답 시간과 작업 처리량 개선을 처리할 수 있음

### 동시성에 대한 이해
- 성능
	- 동시성은 **때로** 성능을 높여줌
	- 동시성은 다수 부하를 유발할 수 있음
- 구조
	- 동시성을 구현하면 싱글 스레드 시스템과 설계가 크게 달라짐
	- 동시성은 복잡함
	- 동시성을 위해서는 근본적인 설계 전략을 재고해야 함
- 버그
	- 동시성 버그는 재현하기 어려워 일회성 문제로 무시하기 쉬움
- 동시성을 관리해주는 컨테이너를 이용할 때
	- 동시성에 대한 이해가 있어야 이후 발생할 수 있는 문제를 해결할 수 있음

## 동시성의 어려움

```ts
class X {
	private lastIdUsed: number;

	getNextId() {
		return ++lastIdUsed;
	}
}
```
- 여러 스레드가 위와 같은 인스턴스를 공유할 경우 원하는 결과가 나오지 않을 수 있음
- 스레드들이 수없이 많은 경로를 지나가는데, 일부 경로에서 잘못된 결과를 내놓기 때문
	- 예를 들어 2개의 스레드가 위의 인스턴스의 메서드를 실행하는 잠재적인 경로는 최대 12,870개

## 동시성 방어 원칙

### 단일 책임 원칙

> [!note] 단일 책임 원칙(SRP; Single Responsibility Principle)
> 주어진 모듈(메서드, 클래스 등)을 변경할 이유는 하나여야 한다.

- 동시성은 복잡성이라는 이유 하나만으로도 단독으로 관리해야 하는 충분조건
- 동시성과 관련된 코드는 다른 코드와 분리해야 함
- 동시성을 구현해야 할 때 고려할 사항들
	- 독자적인 개발, 변경, 조율 주기
	- 독자적인 난관 발생
	- 잘못 구현한 동시성의 실패 방식은 천차만별

### 자료 범위 제한
- 공유 객체를 사용하는 코드 내 임계영역을 `synchronized` 키워드로 보호
- 여기서 중요한 것은 임계영역의 수를 줄이는 기술
	- ⇒ 자료를 캡슐화하고, 공유 자료를 최대한 줄일 것

### 자료 사본 사용
- 공유하지 않는 방법 ⇒ 공유 자료를 복사해 사용
- 사본으로 인한 부하는 공유 자료 동기화로 인한 내부 잠금 실행으로 인한 부하를 상쇄할 가능성이 큼(비용적인 측면에서 우수할 가능성이 있음)

### 스레드는 가능한 독립적으로 구현
- 다른 스레드와 동기화할 필요 없도록, 다른 스레드와 자료를 공유하지 않아야 함

## 다중 스레드 프로그래밍의 실행 모델

### 생산자 - 소비자
- 구조
	- 생산자 스레드: 정보를 생성해 대기열에 추가
	- 소비자 스레드: 대기열에서 정보를 가져와 사용
- 대기열 = 한정된 자원
- 자원을 올바르게 사용하고자 서로 신호를 주고 받음
- 신호가 잘못될 경우, 서로 신호를 기다려 진행하지 못하는 가능성이 생김

### 읽기 - 쓰기
- 구조
	- 읽기 스레드: 공유 자원을 읽어서 사용
	- 쓰기 스레드: 공유 자원을 갱신
- 처리율: 기아 현상이 발생하거나 오래된 정보르 쌓일 가능성 생김
- 고려할 사항
	- 읽기 스레드와 쓰기 스레드의 요구를 적절히 만족시킬 것
	- 적당한 처리율
	- 기아 방지

### 식사하는 철학자들
- 구조
	- 두 개의 스레드가 하나의 자원을 공유하는 상황
	- 하나의 스레드는 자신의 양쪽에 있는 모든 자원을 사용해야 함
- 여러 프로세스가 자원을 얻으려 경쟁하게 됨
- 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪을 수 있음

## 동기화: 메서드 사이의 의존성에 대한 이해
- 공유 객체 하나에는 가능한한 하나의 메서드만 사용 ⇒ 여러 메서드가 하나의 공유 클래스에 동기화된 상태라면 구현이 올바른지 확인이 필요함
- 여러 메스드를 사용해야할 상황에서 고려할 수 있는 방법
	- 클라이언트에서 잠금: 클라이언트에서 첫번째 메서드를 호출하기 전, 마지막 메서드를 호출한 후까지 서버를 잠금
	- 서버에서 잠금: 서버에 `서버를 잠그고 모든 메서드를 호출한 후 잠금 해제` 를 구현하고, 클라이언트에서 해당 메서드를 호출
	- 연결 서버: 잠금을 수행할 중간 단계 생성. 원래 서버를 변경하지 않음

## 동기화 부분을 작게 만들어라
- synchronized 키워드는 락 설정
	- → 락 설정은 스레드 지연, 부하 가중 
	- ⇒ synchronized 키워드 남발 X
- 임계영역
	- 보호해야 하므로, 수를 최대한 줄여야 함
	- 수를 줄인다고 하나의 거대한 임계영역을 만드는 것은 프로그램 성능 저하로 이어질 수 있음

## 올바른 종료 코드는 구현하기 어렵다
- 가장 흔히 발생하는 문제: 데드락
- 깔끔하게 종료하는 다중 스레드 코드는 시간을 투자해 올바르게 작성해야 함
- 이미 나온 알고리즘을 먼저 검토하는 것을 권고

## 스레드 코드 테스트하기
- 테스트는 정확성을 보장하지는 않지만 위험을 낮출 수 있음
⇒ 문제를 노출하는 테스트를 작성할 것

### 저자가 제안하는 테스트 지침
- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
	- 말이 안 되는 오류 != 일회성 문제
	- 일회성 문제가 아닌 시스템 실패이며, 이를 무시하면 잘못된 코드가 계속 쌓일 것
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
	- 순차 코드가 스레드 환경 밖에서 제대로 동작하는지 반드시 확인
	- 스레드의 오류와 순차 코드의 오류를 동시에 디버깅하지 말 것
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣ㅇ을 수 있도록 스레드 코드를  구현하라
	- 다양한 설정으로 실행할 수 있도록 구현할 것
- 다중 스레드를 쓰는 코드 부분을  상황에 맞춰 조정할 수 있게 작성하라
	- 적절한 스레드 개수를 파악하기 위해서는 시행착오가 필요
	- 스레드 개수를 조율하기 쉽도록 코드 구현
- 프로세서 수보다 많은 스레드를 돌려보라
	- 시스템이 스레드를 스와핑할 때도 문제가 발생
	- 해당 문제를 발견하기 위해 프로세서 수보다 많은 스레드를 동작시켜 봄
	- 문제가 있는 코드(임계영역을 빼놓았거나 데드락을 일으키는 등)를 찾기 쉬워짐
- 다른 플랫폼에서 돌려보라
	- 플랫폼마다 스레드 처리하는 정책이 다름 ⇒ 다중 스레드 코드는 플랫폼마다 다르게 동작
	- 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 함
- 코드에 보조 코드를 넣어 돌려라. 갈제로 실패를 일으키게 해보라
	- 스레드의 실패를 강제로 일으켜 버그를 발견하기 위해 보조 코드를 추가한 테스트 실시
	- 방법
		- 직접 구현
			- `wait()`, `sleep()`, `yield()`, `priority()` 함수를 직접 추가
			- 장점: 까다로운 코드를 테스트할 때 적합
			- 고려해야할 점
				- 코드를 삽입할 적정 위치
				- 어떤 함수를 어디서 호출할지
				- 배포 환경에 보조 코드를 남겨둘 가능성
				- 무작위적이어서 버그가 드러나지 않을 수 있음
			- 해결 방법: 스레드를 모르는 POJO와 스레드를  제어하는 클래스로 분할 → 보조 코드를 추가할 위치를 찾기 쉬워짐
		- 자동화
			- 도구를 사용해 코드를 자동으로 추가
			- 권장하는 방법
				- 테스트 멤서드가 없는 클래스를 배포 환경에서 사용
				- 무작위로 보조 코드가 심어진 클래스를 테스트 환경에서 수행
			- 장점: 복잡한 도구를 사용하기 어려울 때 실행하기 좋음
			- 흔들기(jiggle) 기법: 무작위로 nop, sleep, yield 등을 호출 ⇒ 스레드를 매번 다른 순서로 실행하게 함

---

# 발췌

> [!quote]
> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
> **James O. Coplien**
> __
> 226p.

> [!quote]
> 깔끔한 접근 방식을 취한다면 코드가 올바로 돌아갈 가능성이 극적으로 높아진다.
> __
> 244p.

---

# 메모

## 한정된 자원(Bound Resource)
다중 스레드 환경에서 사용하는 자원으로, 크키가 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.

## 상호 배제(Mutual Exclusion)
한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.

## 기아(Starvation)
한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.

## 데드락(Deadlock)
여러 스레드가 서로 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원응ㄹ 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.

## 라이브락(Livelock)
락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.