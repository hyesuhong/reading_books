
> [!info]
> 코드 '냄새'와 저자의 기교, 휴리스틱 소개

# 요약

## 주석(Comment)
- C1: 부적절한 정보
    - 다른 시스템에 저장할 정보는 주석으로 적절하지 않음. 필요하다면 작성자, 최종 수정일, SPR(Software Problem Report) 번호 등의 메타 정보만 주석으로 남길 것
    - 주석은 기술적인 설명을 담당해야 함.
- C2: 쓸모 없는 주석
    - 예: 오래된 주석, 엉뚱한 주석, 잘못된 주석
    - 빠르게 삭제
- C3: 중복된 주석
    - 중복: 코드 내용을 그대로 설명하는 주석, 함수 서명만 하는 Javadoc
    - 삭제
- C4: 성의 없는 주석
    - 주석을 달려면 시간과 정성을 들여 작성할 것
- C5: 주석 처리된 코드
    - 기록은 버전 관리 프로그램에게 맡기고, 발견하면 삭제

## 환경(Environment)
- E1: 여러 단계로 빌드해야 한다
    - 빌드는 한 단계로 끝낼 것
    - 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 함
- E2: 여러 단계로 테스트해야 한다
    - 모든 단위 테스트는 한 명령으로 돌릴 것

## 함수(Function)
- F1: 너무 많은 인수
    - 인수는 적을수록 좋음
    - 넷 이상은 최대한 피할 것
- F2: 출력 인수
    - 함수에서 무언가의 상태를 변경하는 출력인수는 일반적인 인수의 기대를 저버림.
- F3: 플래그 인수
    - true/false의 플래그 인수는 함수가 여러 기능을 수행한다는 증거 ⇒ 피해야 함
- F4: 죽은 함수
    - 죽은 = 아무도 호출하지 않는
    - 사용하지 않는 코드는 곧 낭비. 삭제

## 일반(Generals)
- G1: 한 소스 파일에 여러 언어를 사용한다
    - 소스 파일 하나에 하나의 언어만 사용하는 것이 가장 이상적
    - 최대한 언어 수와 범위를 줄이도록 노력이 필요
- G2: 당연한 동작을 구현하지 않는다
    - 최소 놀람의 원칙(The Principle of Least Surprise)에 의거해 당연하게 여길 만한 동작과 기능을 제공해야 함.
    - 구현하지 않으면 독자가 저자를 신뢰하지 못하고, 코드를 살펴야 함
- G3: 경계를 올바르게 처리하지 않는다
    - 직관에 의존하지 않고, 모든 경계 조건을 찾아내 테스트 후 처리해야 함.
- G4: 안전 절차 무시
    - 안전 절차를 무시하는 것은 위험으로 직결됨
    - 빌드를 쉽게 하기 위해 컴파일러 경고를 끄면 끝없는 디버깅의 늪에 빠질 수 있음
- G5: 중복
    - 중복은 반드시 피할 것
    - 중복을 발견하면 추상화할 기회로 간주 → 추상화 수준을 높임 → 빠른 구현과 적은 오류를 동반
    - 중복 유형
        1. 똑같은 코드가 여러 차례 등장: 함수로 교체
        2. 여러 모듈에서 같은 조건을 확인: 다형성으로 대체
        3. 유사한 알고리즘: Template Method 패턴 혹은 Strategy 패턴으로 제거
    - 대다수의 디자인 패턴 = 중복을 제거하는 잘 알려진 방법
- G6: 추상화 수준이 올바르지 못하다
    - 추상화: 저차원 상세 개념에서 고차원 일반 개념 분리
    - 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 구현 클래스에 넣어야지, 기초 클래스에 넣으면 안 됨
- G7: 기초 클래스가 파생 클래스에 의존한다
    - 고차원 기초 클래스 개념은 저차원 파생 클래스 개념으로부터 독립성을 보장받아야 함
    - = 기초 클래스는 파생 클래스를 몰라야 마땅함
    - 그래야 파생 클래스에 변경이 가해져도 기초 클래스는 변경할 필요가 없음 ⇒ 시스템에 미치는 영향이 작아져 유지보수에 용이
- G8: 과도한 정보
    - 잘 정의된 모듈
        - 작지만 많은 동작이 가능
        - 많은 함수 제공 X ⇒ 결합도가 낮음
- G9: 죽은 코드
    - = 실행되지 않는 코드
    - 삭제하자
    - 예시
        - 불가능한 조건을 확인하는 if문
        - throw문이 없는 try문에서의 catch 블록
        - 호출되지 않는 유틸리티 함수
        - switch/case문에서의 불가능한 case
- G10: 수직 분리
    - 변수와 함수는 사용되는 위치에 가깝게 정의
- G11: 일관성 부족
    - 유사한 개념은 같은 방식으로 구현
    - 표기법도 신중하게 선택하고 따를 것
    - 일관성을 지킴으로서 코드를 읽고 수정하기 쉬워짐
- G12: 잡동사니
    - 사용하지 않는 변수, 호출하지 않는 함수, 잘못된 주석 등 ⇒ 삭제하라
- G13: 인위적 결합
    - 무관한 개념을 인위적으로 결합하지 말 것
    - 목적 없이 변수, 상수, 함수를 위치 시킨 결과 ⇒ 올바른 위치를 고민하고 위치시킬 것
- G14: 기능 욕심
    - 클래스 메서드는 자기 클래스의 변수와 함수에만 관심을 가져야 함
    - 기능 욕심은 클래스의 내부 사정을 노출시키는 행위로 이어지므로 제거하는 것이 좋음
- G15: 선택자 인수
    - 단점: 목적을 기억하기 어려움
    - 함수가 크다는 증거 ⇒ 작은 함수로 나누는 것이 바람직
- G16: 모호한 의도
    - 예시: 같은 행에 표현한 수식, 헝가리식 표기법, 매직 넘버 등
    - 불필요한 것을 제외시키고 의도를 분명히 밝혀야 함
- G17: 잘못 지워진 책임
    - 최소 놀람의 원칙: 독자가 기대할 위치에 코드를 배치시켜야 함
    - 개발하기에 편한 곳에 위치시킬 수도 있지만, 이 때는 이름을 제대로 지어야 함
- G18: 부적절한 static 함수
    - 메서드를 소유하는 객체에서 정보를 가져오거나, 메서드를 재정의할 가능성이 있다면 static이 아닌 인스턴스 함수로 지정해야 함
    - 재정의할 가능성이 static과 인스턴스 함수를 나누는 기준
- G19: 서술적 변수
    - 프로그램 가독성을 높이는 방법 ⇒ 계산을 여러 단계로 나누고 중간 값을 서술적인 변수 이름으로 사용
- G20: 이름과 기능이 일치하는 함수
    - 구현을 살피지 않고도 기능을 예상할 수 있어야 함
- G21: 알고리즘을 이해하라
    - 단순히 돌아가는 단계에서 그치지 않고, 함수가 돌아가는 방식을 이해하고 있는지 확인
    - 함수를 깔끔하고 명확하게 재구성해야 알고리즘이 올바르다는 것을 확인하고 이해할 수 있음
- G22: 논리적 의존성은 물리적으로 드러내라
    - 논리적인 의존성이 존재한다면 인수로 넘기는 등의 물리적 의존성으로 표현해야 함
- G23: `If/Else` 혹은 `Switch/Case` 문보다는 다형성을 사용하라
    - switch문을 선택하기 전에 다형성을 먼저 고려해볼 것
- G24: 표준 표기법을 따르라
    - 업계 표준에 기반한 구현 표준을 따라야 함.
    - 표준을 설명하는 문서는 코드로 충분해야 함.
- G25: 매직 넘버는 명명된 상수로 교체하라
    - 숫자는 상수 뒤로 숨기는 것이 좋음
    - 의미가 주어지기 때문
    - 코드 자체가 자명하다면 그냥 숫자로 써도 괜찮음
- G26: 정확하라
    - 코드에서 무언가를 결정할 때는 정확히 결정할 것
    - 예외 처리, 반환값 등을 점검할 것
- G27: 관례보다 구조를 사용하라
    - 설계를 강제할 때 ⇒ 규칙보다는 관례 사용
    - 구조 자체로 강제하는 것이 좋음
- G28: 조건을 캡슐화하라
    - 조건의 의도를 밝히는 함수로 표현하는 것이 이해를 도움
- G29: 부정 조건은 피하라
    - 사람은 부정보다 긍정을 더 잘 이해함
- G30: 함수는 한 가지만 해야 한다
- G31: 숨겨진 시간적인 결합
    - 시간적인 결합이 필요하다면, 순서를 드러내야 함
    - 인수로 전달해 시간적인 결합을 강제하는 것이 오류를 막는 방법
- G32: 일관성을 유지하라
    - 코드 구조를 고민한 이유를 명백히 표현
    - 일관성이 있다면, 다른 사람들도 일관성을 따르고 보존함
- G33: 경계 조건을 캡슐화하라
    - 경계 조건은 한 곳에서 별도로 처리
- G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
- G35: 설정 정보는 최상위 단계에 두어라
    - 기본값 상수, 설정 관련 상수는 추상화 최상위 단계에 위치시켜야 함.
    - 저차원 함수 안에 숨겨서는 안 됨. → 저차원 함수에 인수로 넘겨줌
- G36: 추이적 탐색을 피하라
    - 디미터의 법칙(Law of Demeter), 부끄럼 타는 코드 작성(Writing Shy Code)
    - 자신이 직접 사용하는 모듈만 알아야 함
    - 주변 모듈을 알아야 한다면, 아키텍처에 유연성이 없어짐

## 자바(Java)
- J1: 긴 import 목록을 피하고 와일드카드(`*`)를 사용하라
    - 와일드카드의 장점
        - 읽기에 부담스럽지 않음(짧아서)
        - 패키지를 검색 경로에 추가하는 것이어서 의존성, 결합성이 낮아짐
- J2: 상수는 상속하지 않는다
    - 추상화 최상위에 위치한 상수를 하위 함수 혹은 클래스에 상속해서는 안 됨
    - static import를 사용할 것
- J3: 상수 vs Enum
    - enum을 사용할 수 있다면, enum을 사용할 것
    - 이름이 부여된 열거체이기 때문에 의미를 잃지 않음
    - 메서드와 필드를 사용할 수 있어 유연하고 서술적인 도구

## 이름(Name)
- N1: 서술적인 이름을 사용하라
    - 서술적인 이름을 신중이 선택하고, 소프트웨어가 진화할 때마다 이름이 여전히 적합한지 자주 확인 필요
    - 잘 선택한 이름은 주석으로 설명하는 것보다 강력함
- N2: 적절한 추상화 수준에서 이름을 선택하라
    - 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택할 것
- N3: 가능하다면 표준 명명법을 사용하라
    - 기존 명명법을 사용하는 이름은 이해하기 쉬움
        - 예시: DECORATOR 패턴을 사용하는 `AutoHangupModemDecorator` 메서드
    - 팀에서 정한 표준을 사용할 것
- N4: 명확한 이름
    - 목적을 정확히 밝히는 이름 사용
- N5: 긴 범위는 긴 이름을 사용하라
    - 이름의 길이는 범위 길이에 비례
    - 범위가 5줄 안팎이면 `i` `j` 같은 변수도 괜찮음
- N6: 인코딩을 피하라
    - 헝가리안 표기법과 같은 오래된 방식을 벗어날 것
    - 독자만 혼란하게 만듦
- N7: 이름으로 부수 효과를 설명하라
    - 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용할 것

## 테스트(Test)
- T1: 불충분한 테스트
    - 테스트는 모든 조건이나 계산을 검증해야 함
    - 검증하지 않는 코드가 있다면 테스트가 불충분한 것
- T2: 커버리지 도구를 사용하라
    - 커버리지 도구는 테스트가 빠뜨리는 공백을 알려줌
    - 테스트 작성도 사람이 하는 것이기 때문에 놓치는 부분이 생길 수 있음
    - 커버리지 도구를 사용해 테스트가 불충분한 부분을 쉽게 찾을 수 있음
- T3: 사소한 테스트를 건너뛰지 마라
    - 적은 비용으로 높은 문서적 가치를 얻을 수 있음
- T4: 무시한 테스트는 모호함을 뜻한다
    - 주석 처리 혹은 @Ignore 표시된 테스트는 요구사항이 불분명함을 드러냄
- T5: 경계 조건을 테스트하라
    - 각별히 신경 써서 테스트해야 함
- T6: 버그 주변은 철저히 테스트하라
    - 버그가 발견된 곳은 다른 버그가 존재할 가능성이 높음
- T7: 실패 패턴을 살펴라
    - 실패하는 패턴으로 문제를 진단할 수도 있음
    - 합리적인 순서로 정렬된 테스트 케이스는 실패 패턴을 드러냄
- T8: 테스트 커버리지 패턴을 살펴라
    - 통과하는 테스트를 살펴보면 실패하는 테스트의 원인을 알 수 있음
- T9: 테스트는 빨라야 한다
    - 빨리 진행되면 테스트를 자주 돌릴 수 있음
    - 느리다면 일정에 쫓겨 건너뛸 가능성이 가장 높은 단계가 테스트 단계

---

# 발췌

> [!quote]
>  함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

> [!quote]
> 휴리스틱 목록을 익힌다고 소프트웨어 장인이 되지는 못한다. 전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.
> __
> 406p.
