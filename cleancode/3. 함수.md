# 요약

## 작게 만들어라
- 함수를 만드는 첫번째 규칙
- 블록과 들여쓰기를 기준으로 1단 혹은 2단을 넘어서면 안 된다.
	- 함수의 중첩 구조가 적은 만큼 이해하기 쉽고 가독성이 높아진다.

## 한 가지만 해라
- `한 가지` : [[#추상화]] 수준이 하나
- 함수 내에서 의미 있는 이름으로 다른 함수를 추출할 수 있다면 해당 함수는 여러 작업을 한다고 볼 수 있다.
- 자연스럽게 섹션으로 나눌 수 있는 함수는 여러 작업을 하고 있다는 증거다.

## 함수 당 추상화 수준은 하나로
- 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
	- 추상화 수준이 섞여있으면 코드를 읽을 때 헷갈릴 수 있다.
- 내려가기 규칙
	- 위에서 아래로 코드를 읽으면 함수 추상화 수준이 한 단계씩 낮아지는 규칙

## Switch 문
- Switch 문은 작게 만들기 어렵다
	- case 개수만큼의 N가지 조건을 처리한다는 본질 때문
	- 다른 조건이 생길 때마다 case 구문을 추가해야 한다
		- 더 길어질 가능성이 존재
		- 빈번한 코드 변경이 요구됨
- 저자는 switch 문을 저차원 클래스에 숨긴 뒤, 상속 관계로 호출해 다른 코드에 노출하지 않는 방법을 제안한다.

## 서술적인 이름을 사용하라
- 함수가 하는 일을 잘 표현하는 방법
- 주석보다는 함수 이름이 길어지는 것이 좋다
- 서술적인 이름은 함수 설계를 더 뚜렷하게 한다 ⇒ 코드 개선이 쉬워진다

## 함수 인수
- 인수는 적을수록 좋다 ⇒ 가장 이상적인 개수는 0개
- 테스트 관점에서 인수가 많을수록 어렵다 ⇒ 인수의 개수만큼 경우의 수가 증가하기 때문
### 단항 형식
- 사용하는 경우
	- 인수에 질문을 던지는 함수
	- 인수를 다른 것으로 변환한 결과를 반환하는 함수
### 플래그 인수(boolean을 전달하는 단항 함수)
- 사용하지 않는 편이 좋음 ⇒ 함수가 한 번에 여러 일을 한다고 알리는 셈
- 각각의 함수를 따로 만들어 호출하는 것이 더 나음
### 이항 함수(인수 2개)
- 적절한 사용인 경우
	- 좌표와 같이 일반적으로 2개의 인수를 취하는 경우
	- 2개의 인수가 자연적인 순서를 가지는 경우
### 삼항 함수(인수 3개)
- 인수가 늘어난만큼 한 번에 이해하기 어렵다 ⇒ 신중히 고려해야 한다
### 인수 객체
- 인수가 2개 이상 필요하다면, 독자적인 클래스로 선언할 가능성을 살펴본다.
- 인수를 객체로 받을 경우, 이름을 붙여야 하기 때문에 해당 개념을 설명하게 된다 ⇒ 함수를 좀 더 이해할 수 있다.
### 인수 목록
- 때로는 인수 개수가 가변적인 함수가 필요하다
- 사실 가변 인수는 리스트형 인수 하나(`...args`)로 치환할 수 있으며, 단항, 이항, 삼항 함수와 같다
### 동사와 키워드
- 함수의 의도, 인수의 순서와 의도를 제대로 표현하기 위한 방법
	- 함수와 인수가 동사/명사 짝을 이루어야 한다.
		- `write(name)`
	- 함수의 이름에 인수 이름을 넣는다 ⇒ 인수의 순서를 기억하지 않아도 됨다
		- `assertEquals` ⇒ `assertExpectedEqualsActual`

## 부수 효과를 일으키지 마라
- 함수가 하겠다고 약속한 것 외에 다른 것을 해서는 안 된다. ⇒ 시간적인 결합이나 순서 종속성을 초래
	- 시간적인 결합(temporal coupling): 코드의 일부가 서로 관련되어 있고, 실행의 순서가 연결되어 있는 것
	- 순서 종속성(order dependency)
### 출력 인수
- 일반적으로 인수는 함수에 입력하는 것으로 해석한다.
- 출력 인수는 함수 선언부를 찾아봐야 이해할 수 있다
	- 출력 인수를 사용하는 대신 함수가 속한 객체 상태를 변경하는 방식을 선택하자

## 명령과 조회를 분리하라
- 함수가 할 수 있는 두 가지 작업
	- 명령: 무언가를 수행
	- 조회: 무언가에 응답
- 둘 다 하는 함수는 혼란을 초래한다 ⇒ 한 가지만 한다는 규칙을 위배하기 때문

## 오류 코드보다는 예외를 사용하라
- 명령 함수에서 오류 코드를 반환하는 방식은 명령과 조회를 분리하는 규칙을 위배
- 저자는 오류 코드 반환 대신 `try-catch` 구문으로 예외 처리를 사용하는 것이 좋다고 주장
### try-catch 블록 뽑아내기
- `try-catch` 구조는 정상 동작과 오류 동작이 함께 있기 때문에 혼란을 일으킬 수 있다
- 별도 함수로 관리하는 것을 추천
### 오류 처리도 한 가지 작업이다
- 오류 처리도 한 가지 작업에 속하기 때문에 오류를 처리하는 함수가 따로 있어야 한다
### `Error.java` 의존성 자석
- 오류 코드를 반환할 경우의 문제점 중 하나
- 어디선가 정의된 Error 클래스를 항상 import 해서 사용해야 하는 의존성이 존재
- 예외는 Exception 클래스에서 파생되는데, 재컴파일/재배치 없이 새로운 예외 클래스를 추가할 수 있어 번거로움 축소

## 반복하지 마라
- 중복은 소프르웨어에서 모든 악의 근원
- 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 등장
	- E. F. 커드(E. F. Codd): 자료에서 중복을 제거할 목적으로 관계형 데이터베이스에서 정규 형식을 만듦
	- 객체지향 프로그래밍: 코드를 부모 클래스로 몰아 중복 방지
	- 구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 등

## 구조적 프로그래밍
- 구조적 프로그래밍의 규율(에츠허르 데이크스트라의 규율)
    - "모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다."
        - return 문은 하나
        - loop 내에서 break, continue, goto를 사용해서는 안 됨
- 현재 책에서 설명하는 함수는 작은 단위의 함수
    - 구조적 프로그래밍의 규율은 함수가 큰 경우에만 효과적 ⇒ 함수가 작다면 위의 규율을 따르지 않아도 됨
    - return, break, continue 를 여러 차례 사용하는 것이 단일 입/출구 보다 의도를 표현하기 쉽다고 설명
    - goto 문은 작은 함수에서도 피해야 한다.

## 함수를 어떻게 짜죠?
- 함수 작성 = 글짓기
- 초안을 서툴게 작성한 뒤 읽기 좋게 다듬는 글쓰기처럼, 함수 작성도 차례차례 코드를 다듬어간다.
- 코드를 개선하는 중에도 단위 테스트를 항상 통과해야 한다.

---

# 발췌

> [!quote]
> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
> __
> 44p.

> [!quote]
> 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다. 하지만 문제는 이 정도로 그치지 않는다. 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.
> __
> 46p.

> [!quote]
> 내가 함수를 짤 때도 마찬가지다. 처음에는 길고 복잡하다.
> …
> 그런 다음 나는 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다.
> __
> 61p.

> [!quote]
> 대가 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.
> __
> 62p.

> [!quote]
> 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다. 여러분이 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기 쉬워진다는 사실을 기억하기 바란다.
> __
> 62p.

---

# 메모
## 추상화
[IT 용어 사전](https://terms.naver.com/entry.naver?docId=859502&cid=42346&categoryId=42346)에서의 설명
> [!info]
> 컴퓨터 과학 분야에서 주어진 문제나 시스템의 복잡도를 단순화하여 인식하기 쉽게 만드는 개념화 작업

## 추상화 수준
- 높은 추상화 수준: 더 이상 단순화할 수 없음